#include "include.h"
using namespace std;
typedef int ElementType;
class Unit_7
{
public:
	Unit_7();
	~Unit_7();
	void test_function();
	void Bubble_Sort(int A[],int N);
	void Insertion_Sort(int A[],int N);
	void Shell_Sort(int A[],int N);
	void Swap( ElementType *a, ElementType *b )
	{
		 ElementType t = *a; *a = *b; *b = t;
	}  
	void PercDown( ElementType A[], int p, int N )
	{ /* 改编代码4.24的PercDown( MaxHeap H, int p )    */
	  /* 将N个元素的数组中以A[p]为根的子堆调整为最大堆 */
		int Parent, Child;
		ElementType X;
 
		X = A[p]; /* 取出根结点存放的值 */
		for( Parent=p; (Parent*2+1)<N; Parent=Child ) {
			Child = Parent * 2 + 1;
			if( (Child!=N-1) && (A[Child]<A[Child+1]) )
				Child++;  /* Child指向左右子结点的较大者 */
			if( X >= A[Child] ) break; /* 找到了合适位置 */
			else  /* 下滤X */
				A[Parent] = A[Child];
		}
		A[Parent] = X;
	}
	void HeapSort( ElementType A[], int N );
	/* 归并排序 - 递归实现 */
	/* L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置*/
	void Merge( ElementType A[], ElementType TmpA[], int L, int R, int RightEnd )
	{ /* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 */
		 int LeftEnd, NumElements, Tmp;
		 int i;
      
		 LeftEnd = R - 1; /* 左边终点位置 */
		 Tmp = L;         /* 有序序列的起始位置 */
		 NumElements = RightEnd - L + 1;
      
		 while( L <= LeftEnd && R <= RightEnd ) {
			 if ( A[L] <= A[R] )
				 TmpA[Tmp++] = A[L++]; /* 将左边元素复制到TmpA */
			 else
				 TmpA[Tmp++] = A[R++]; /* 将右边元素复制到TmpA */
		 }
 
		 while( L <= LeftEnd )
			 TmpA[Tmp++] = A[L++]; /* 直接复制左边剩下的 */
		 while( R <= RightEnd )
			 TmpA[Tmp++] = A[R++]; /* 直接复制右边剩下的 */
          
		 for( i = 0; i < NumElements; i++ )
			 A[RightEnd] = TmpA[RightEnd--]; /* 将有序的TmpA[]复制回A[] */
	}
	void Msort( ElementType A[], ElementType TmpA[], int L, int RightEnd )
	{ /* 核心递归排序函数 */ 
		 int Center;
      
		 if ( L < RightEnd ) {
			  Center = (L+RightEnd) / 2;
			  Msort( A, TmpA, L, Center );              /* 递归解决左边 */ 
			  Msort( A, TmpA, Center+1, RightEnd );     /* 递归解决右边 */  
			  Merge( A, TmpA, L, Center+1, RightEnd );  /* 合并两段有序序列 */ 
		 }
	}
	void MergeSort( ElementType A[], int N );

	/* 归并排序 - 循环实现 */
	/* 这里Merge函数在递归版本中给出 */
	/* length = 当前有序子列的长度*/
	void Merge_pass( ElementType A[], ElementType TmpA[], int N, int length )
	{ /* 两两归并相邻有序子列 */
		 int i, j;
       
		 for ( i=0; i <= N-2*length; i += 2*length )
			 Merge( A, TmpA, i, i+length, i+2*length-1 );
		 if ( i+length < N ) /* 归并最后2个子列*/
			 Merge( A, TmpA, i, i+length, N-1);
		 else /* 最后只剩1个子列*/
			 for ( j = i; j < N; j++ ) TmpA[j] = A[j];
	}
	void Merge_Sort( ElementType A[], int N )
	{ 
		 int length; 
		 ElementType *TmpA;
      
		 length = 1; /* 初始化子序列长度*/
		 TmpA = (ElementType*)malloc( N * sizeof( ElementType ) );
		 if ( TmpA != NULL ) {
			  while( length < N ) {
				  Merge_pass( A, TmpA, N, length );//控制空间复杂度，TmpA->A  A->TmpA TmpA->A  A->TempA
				  length *= 2;
				  Merge_pass( TmpA, A, N, length );
				  length *= 2;
			  }
			  free( TmpA );
		 }
		 else printf( "空间不足" );
	}
};